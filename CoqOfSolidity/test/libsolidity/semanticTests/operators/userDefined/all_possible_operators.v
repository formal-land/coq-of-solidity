(* Generated by coq-of-solidity *)
Require CoqOfSolidity.CoqOfSolidity.

Axiom user_type_Int : Ty.path "Int" = Ty.path "int8".
(* Beginning of a node! *)
id: 21
src: 18:212:0
nodeType: UsingForDirective
typeName: (* Beginning of a node! *)
id: 20
src: 219:3:0
nodeType: UserDefinedTypeName
pathNode: (* Beginning of a node! *)
id: 19
src: 219:3:0
nodeType: IdentifierPath
name: Int
nameLocations: [219:3:0, ]
referencedDeclaration: 2

referencedDeclaration: 2
typeDescriptions: typeString InttypeIdentifier st_userDefinedValueType$_Int_$2

functionList: [{definition: (* Beginning of a node! *)
id: 3
src: 30:5:0
nodeType: IdentifierPath
name: bitor
nameLocations: [30:5:0, ]
referencedDeclaration: 47
, operator: |, }, {definition: (* Beginning of a node! *)
id: 4
src: 42:6:0
nodeType: IdentifierPath
name: bitand
nameLocations: [42:6:0, ]
referencedDeclaration: 73
, operator: &, }, {definition: (* Beginning of a node! *)
id: 5
src: 55:6:0
nodeType: IdentifierPath
name: bitxor
nameLocations: [55:6:0, ]
referencedDeclaration: 99
, operator: ^, }, {definition: (* Beginning of a node! *)
id: 6
src: 68:6:0
nodeType: IdentifierPath
name: bitnot
nameLocations: [68:6:0, ]
referencedDeclaration: 118
, operator: ~, }, {definition: (* Beginning of a node! *)
id: 7
src: 85:3:0
nodeType: IdentifierPath
name: add
nameLocations: [85:3:0, ]
referencedDeclaration: 144
, operator: +, }, {definition: (* Beginning of a node! *)
id: 8
src: 95:3:0
nodeType: IdentifierPath
name: sub
nameLocations: [95:3:0, ]
referencedDeclaration: 170
, operator: -, }, {definition: (* Beginning of a node! *)
id: 9
src: 105:5:0
nodeType: IdentifierPath
name: unsub
nameLocations: [105:5:0, ]
referencedDeclaration: 189
, operator: -, }, {definition: (* Beginning of a node! *)
id: 10
src: 117:3:0
nodeType: IdentifierPath
name: mul
nameLocations: [117:3:0, ]
referencedDeclaration: 215
, operator: *, }, {definition: (* Beginning of a node! *)
id: 11
src: 127:3:0
nodeType: IdentifierPath
name: div
nameLocations: [127:3:0, ]
referencedDeclaration: 241
, operator: /, }, {definition: (* Beginning of a node! *)
id: 12
src: 137:3:0
nodeType: IdentifierPath
name: mod
nameLocations: [137:3:0, ]
referencedDeclaration: 267
, operator: %, }, {definition: (* Beginning of a node! *)
id: 13
src: 151:2:0
nodeType: IdentifierPath
name: eq
nameLocations: [151:2:0, ]
referencedDeclaration: 289
, operator: ==, }, {definition: (* Beginning of a node! *)
id: 14
src: 161:5:0
nodeType: IdentifierPath
name: noteq
nameLocations: [161:5:0, ]
referencedDeclaration: 311
, operator: !=, }, {definition: (* Beginning of a node! *)
id: 15
src: 174:2:0
nodeType: IdentifierPath
name: lt
nameLocations: [174:2:0, ]
referencedDeclaration: 333
, operator: <, }, {definition: (* Beginning of a node! *)
id: 16
src: 183:2:0
nodeType: IdentifierPath
name: gt
nameLocations: [183:2:0, ]
referencedDeclaration: 355
, operator: >, }, {definition: (* Beginning of a node! *)
id: 17
src: 192:3:0
nodeType: IdentifierPath
name: leq
nameLocations: [192:3:0, ]
referencedDeclaration: 377
, operator: <=, }, {definition: (* Beginning of a node! *)
id: 18
src: 203:3:0
nodeType: IdentifierPath
name: geq
nameLocations: [203:3:0, ]
referencedDeclaration: 399
, operator: >=, }, ]
global: 1

Definition bitor (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.call (|
          M.member_access (|
            M.get_name (| "Int" |),
            "wrap"
          |),
          [
            M.bin_op (|
              "|",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "x" |)
                ]
              |),
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "y" |)
                ]
              |)
            |)
          ]
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.
Definition bitand (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.call (|
          M.member_access (|
            M.get_name (| "Int" |),
            "wrap"
          |),
          [
            M.bin_op (|
              "&",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "x" |)
                ]
              |),
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "y" |)
                ]
              |)
            |)
          ]
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.
Definition bitxor (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.call (|
          M.member_access (|
            M.get_name (| "Int" |),
            "wrap"
          |),
          [
            M.bin_op (|
              "^",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "x" |)
                ]
              |),
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "y" |)
                ]
              |)
            |)
          ]
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.
Definition bitnot (α : list Value.t) : M :=
  match α with
  | [x] =>
    let _ :=
      M.return_ (|
        M.call (|
          M.member_access (|
            M.get_name (| "Int" |),
            "wrap"
          |),
          [
            M.un_op (|
              true,
              "~",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "x" |)
                ]
              |)
            |)
          ]
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.
Definition add (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.call (|
          M.member_access (|
            M.get_name (| "Int" |),
            "wrap"
          |),
          [
            M.bin_op (|
              "+",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "x" |)
                ]
              |),
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "y" |)
                ]
              |)
            |)
          ]
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.
Definition sub (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.call (|
          M.member_access (|
            M.get_name (| "Int" |),
            "wrap"
          |),
          [
            M.bin_op (|
              "-",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "x" |)
                ]
              |),
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "y" |)
                ]
              |)
            |)
          ]
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.
Definition unsub (α : list Value.t) : M :=
  match α with
  | [x] =>
    let _ :=
      M.return_ (|
        M.call (|
          M.member_access (|
            M.get_name (| "Int" |),
            "wrap"
          |),
          [
            M.un_op (|
              true,
              "-",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "x" |)
                ]
              |)
            |)
          ]
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.
Definition mul (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.call (|
          M.member_access (|
            M.get_name (| "Int" |),
            "wrap"
          |),
          [
            M.bin_op (|
              "*",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "x" |)
                ]
              |),
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "y" |)
                ]
              |)
            |)
          ]
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.
Definition div (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.call (|
          M.member_access (|
            M.get_name (| "Int" |),
            "wrap"
          |),
          [
            M.bin_op (|
              "/",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "x" |)
                ]
              |),
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "y" |)
                ]
              |)
            |)
          ]
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.
Definition mod (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.call (|
          M.member_access (|
            M.get_name (| "Int" |),
            "wrap"
          |),
          [
            M.bin_op (|
              "%",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "x" |)
                ]
              |),
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.get_name (| "y" |)
                ]
              |)
            |)
          ]
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.
Definition eq (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.bin_op (|
          "==",
          M.call (|
            M.member_access (|
              M.get_name (| "Int" |),
              "unwrap"
            |),
            [
              M.get_name (| "x" |)
            ]
          |),
          M.call (|
            M.member_access (|
              M.get_name (| "Int" |),
              "unwrap"
            |),
            [
              M.get_name (| "y" |)
            ]
          |)
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.
Definition noteq (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.bin_op (|
          "!=",
          M.call (|
            M.member_access (|
              M.get_name (| "Int" |),
              "unwrap"
            |),
            [
              M.get_name (| "x" |)
            ]
          |),
          M.call (|
            M.member_access (|
              M.get_name (| "Int" |),
              "unwrap"
            |),
            [
              M.get_name (| "y" |)
            ]
          |)
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.
Definition lt (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.bin_op (|
          "<",
          M.call (|
            M.member_access (|
              M.get_name (| "Int" |),
              "unwrap"
            |),
            [
              M.get_name (| "x" |)
            ]
          |),
          M.call (|
            M.member_access (|
              M.get_name (| "Int" |),
              "unwrap"
            |),
            [
              M.get_name (| "y" |)
            ]
          |)
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.
Definition gt (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.bin_op (|
          ">",
          M.call (|
            M.member_access (|
              M.get_name (| "Int" |),
              "unwrap"
            |),
            [
              M.get_name (| "x" |)
            ]
          |),
          M.call (|
            M.member_access (|
              M.get_name (| "Int" |),
              "unwrap"
            |),
            [
              M.get_name (| "y" |)
            ]
          |)
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.
Definition leq (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.bin_op (|
          "<=",
          M.call (|
            M.member_access (|
              M.get_name (| "Int" |),
              "unwrap"
            |),
            [
              M.get_name (| "x" |)
            ]
          |),
          M.call (|
            M.member_access (|
              M.get_name (| "Int" |),
              "unwrap"
            |),
            [
              M.get_name (| "y" |)
            ]
          |)
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.
Definition geq (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.bin_op (|
          ">=",
          M.call (|
            M.member_access (|
              M.get_name (| "Int" |),
              "unwrap"
            |),
            [
              M.get_name (| "x" |)
            ]
          |),
          M.call (|
            M.member_access (|
              M.get_name (| "Int" |),
              "unwrap"
            |),
            [
              M.get_name (| "y" |)
            ]
          |)
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.
(* Contract *)
Module C.
  Definition ZERO : Value.t :=
    M.call (|
      M.member_access (|
        M.get_name (| "Int" |),
        "wrap"
      |),
      [
        Value.Integer 0
      ]
    |).

  Definition ONE : Value.t :=
    M.call (|
      M.member_access (|
        M.get_name (| "Int" |),
        "wrap"
      |),
      [
        Value.Integer 1
      ]
    |).

  Definition TWO : Value.t :=
    M.call (|
      M.member_access (|
        M.get_name (| "Int" |),
        "wrap"
      |),
      [
        Value.Integer 2
      ]
    |).

  Definition THREE : Value.t :=
    M.call (|
      M.member_access (|
        M.get_name (| "Int" |),
        "wrap"
      |),
      [
        Value.Integer 3
      ]
    |).

  Definition SIX : Value.t :=
    M.call (|
      M.member_access (|
        M.get_name (| "Int" |),
        "wrap"
      |),
      [
        Value.Integer 6
      ]
    |).

  Definition testBitwise (α : list Value.t) : M :=
    match α with
    | [] =>
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "|",
                    M.get_name (| "ONE" |),
                    M.get_name (| "TWO" |)
                  |)
                ]
              |),
              Value.Integer 3
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "|",
                    M.get_name (| "ONE" |),
                    M.get_name (| "ZERO" |)
                  |)
                ]
              |),
              Value.Integer 1
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "&",
                    M.get_name (| "ONE" |),
                    M.get_name (| "THREE" |)
                  |)
                ]
              |),
              Value.Integer 1
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "&",
                    M.get_name (| "ONE" |),
                    M.get_name (| "ONE" |)
                  |)
                ]
              |),
              Value.Integer 1
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "^",
                    M.get_name (| "TWO" |),
                    M.get_name (| "TWO" |)
                  |)
                ]
              |),
              Value.Integer 0
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "^",
                    M.get_name (| "TWO" |),
                    M.get_name (| "ONE" |)
                  |)
                ]
              |),
              Value.Integer 3
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.un_op (|
                    true,
                    "~",
                    M.get_name (| "ZERO" |)
                  |)
                ]
              |),
              M.un_op (|
                true,
                "-",
                Value.Integer 1
              |)
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.un_op (|
                    true,
                    "~",
                    M.get_name (| "ONE" |)
                  |)
                ]
              |),
              M.un_op (|
                true,
                "-",
                Value.Integer 2
              |)
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.un_op (|
                    true,
                    "~",
                    M.get_name (| "TWO" |)
                  |)
                ]
              |),
              M.un_op (|
                true,
                "-",
                Value.Integer 3
              |)
            |)
          ]
        |) in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition testArithmetic (α : list Value.t) : M :=
    match α with
    | [] =>
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "+",
                    M.get_name (| "ONE" |),
                    M.get_name (| "TWO" |)
                  |)
                ]
              |),
              Value.Integer 3
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "+",
                    M.get_name (| "ONE" |),
                    M.get_name (| "ZERO" |)
                  |)
                ]
              |),
              Value.Integer 1
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "-",
                    M.get_name (| "TWO" |),
                    M.get_name (| "ONE" |)
                  |)
                ]
              |),
              Value.Integer 1
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "-",
                    M.get_name (| "THREE" |),
                    M.get_name (| "THREE" |)
                  |)
                ]
              |),
              Value.Integer 0
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.un_op (|
                    true,
                    "-",
                    M.get_name (| "TWO" |)
                  |)
                ]
              |),
              M.un_op (|
                true,
                "-",
                Value.Integer 2
              |)
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.un_op (|
                    true,
                    "-",
                    M.get_name (| "ZERO" |)
                  |)
                ]
              |),
              Value.Integer 0
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "*",
                    M.get_name (| "ONE" |),
                    M.get_name (| "ONE" |)
                  |)
                ]
              |),
              Value.Integer 1
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "*",
                    M.get_name (| "THREE" |),
                    M.get_name (| "TWO" |)
                  |)
                ]
              |),
              Value.Integer 6
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "/",
                    M.get_name (| "SIX" |),
                    M.get_name (| "TWO" |)
                  |)
                ]
              |),
              Value.Integer 3
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "/",
                    M.get_name (| "THREE" |),
                    M.get_name (| "TWO" |)
                  |)
                ]
              |),
              Value.Integer 1
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "%",
                    M.get_name (| "SIX" |),
                    M.get_name (| "TWO" |)
                  |)
                ]
              |),
              Value.Integer 0
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              M.call (|
                M.member_access (|
                  M.get_name (| "Int" |),
                  "unwrap"
                |),
                [
                  M.bin_op (|
                    "%",
                    M.get_name (| "THREE" |),
                    M.get_name (| "TWO" |)
                  |)
                ]
              |),
              Value.Integer 1
            |)
          ]
        |) in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition testComparison (α : list Value.t) : M :=
    match α with
    | [] =>
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              Value.Tuple [
                M.bin_op (|
                  "==",
                  M.get_name (| "ONE" |),
                  M.get_name (| "ONE" |)
                |)
              ],
              Value.Bool true
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              Value.Tuple [
                M.bin_op (|
                  "==",
                  M.get_name (| "ONE" |),
                  M.get_name (| "TWO" |)
                |)
              ],
              Value.Bool false
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              Value.Tuple [
                M.bin_op (|
                  "!=",
                  M.get_name (| "ONE" |),
                  M.get_name (| "ONE" |)
                |)
              ],
              Value.Bool false
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              Value.Tuple [
                M.bin_op (|
                  "!=",
                  M.get_name (| "ONE" |),
                  M.get_name (| "TWO" |)
                |)
              ],
              Value.Bool true
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              Value.Tuple [
                M.bin_op (|
                  "<",
                  M.get_name (| "ONE" |),
                  M.get_name (| "TWO" |)
                |)
              ],
              Value.Bool true
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              Value.Tuple [
                M.bin_op (|
                  "<",
                  M.get_name (| "TWO" |),
                  M.get_name (| "ONE" |)
                |)
              ],
              Value.Bool false
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              Value.Tuple [
                M.bin_op (|
                  "<=",
                  M.get_name (| "ONE" |),
                  M.get_name (| "TWO" |)
                |)
              ],
              Value.Bool true
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              Value.Tuple [
                M.bin_op (|
                  "<=",
                  M.get_name (| "TWO" |),
                  M.get_name (| "ONE" |)
                |)
              ],
              Value.Bool false
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              Value.Tuple [
                M.bin_op (|
                  ">",
                  M.get_name (| "ONE" |),
                  M.get_name (| "TWO" |)
                |)
              ],
              Value.Bool false
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              Value.Tuple [
                M.bin_op (|
                  ">",
                  M.get_name (| "TWO" |),
                  M.get_name (| "ONE" |)
                |)
              ],
              Value.Bool true
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              Value.Tuple [
                M.bin_op (|
                  ">=",
                  M.get_name (| "ONE" |),
                  M.get_name (| "TWO" |)
                |)
              ],
              Value.Bool false
            |)
          ]
        |) in
      let _ :=
        M.call (|
          M.get_name (| "assert" |),
          [
            M.bin_op (|
              "==",
              Value.Tuple [
                M.bin_op (|
                  ">=",
                  M.get_name (| "TWO" |),
                  M.get_name (| "ONE" |)
                |)
              ],
              Value.Bool true
            |)
          ]
        |) in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.
End C.
