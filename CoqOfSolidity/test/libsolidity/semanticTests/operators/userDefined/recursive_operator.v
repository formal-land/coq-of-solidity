(* Generated by coq-of-solidity *)
Require CoqOfSolidity.CoqOfSolidity.

Axiom user_type_Uint : Ty.path "Uint" = Ty.path "uint".
(* Beginning of a node! *)
id: 8
src: 19:76:0
nodeType: UsingForDirective
typeName: (* Beginning of a node! *)
id: 7
src: 83:4:0
nodeType: UserDefinedTypeName
pathNode: (* Beginning of a node! *)
id: 6
src: 83:4:0
nodeType: IdentifierPath
name: Uint
nameLocations: [83:4:0, ]
referencedDeclaration: 2

referencedDeclaration: 2
typeDescriptions: typeString UinttypeIdentifier st_userDefinedValueType$_Uint_$2

functionList: [{definition: (* Beginning of a node! *)
id: 3
src: 26:14:0
nodeType: IdentifierPath
name: unaryCountdown
nameLocations: [26:14:0, ]
referencedDeclaration: 41
, operator: ~, }, {definition: (* Beginning of a node! *)
id: 4
src: 47:15:0
nodeType: IdentifierPath
name: binaryCountdown
nameLocations: [47:15:0, ]
referencedDeclaration: 96
, operator: ^, }, {definition: (* Beginning of a node! *)
id: 5
src: 69:2:0
nodeType: IdentifierPath
name: eq
nameLocations: [69:2:0, ]
referencedDeclaration: 118
, operator: ==, }, ]
global: 1

Definition unaryCountdown (α : list Value.t) : M :=
  match α with
  | [x] =>
    let _ :=
      if M.bin_op (|
        "==",
        M.get_name (| "x" |),
        M.call (|
          M.member_access (|
            M.get_name (| "Uint" |),
            "wrap"
          |),
          [
            Value.Integer 0
          ]
        |)
      |) then
        M.return_ (|
          M.call (|
            M.member_access (|
              M.get_name (| "Uint" |),
              "wrap"
            |),
            [
              Value.Integer 0
            ]
          |)
        |)
      else
        Value.Tuple [] in
    let _ :=
      M.return_ (|
        M.un_op (|
          true,
          "~",
          M.call (|
            M.member_access (|
              M.get_name (| "Uint" |),
              "wrap"
            |),
            [
              M.bin_op (|
                "-",
                M.call (|
                  M.member_access (|
                    M.get_name (| "Uint" |),
                    "unwrap"
                  |),
                  [
                    M.get_name (| "x" |)
                  ]
                |),
                Value.Integer 1
              |)
            ]
          |)
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.
Definition binaryCountdown (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      if M.bin_op (|
        "&&",
        M.bin_op (|
          "==",
          M.get_name (| "x" |),
          M.call (|
            M.member_access (|
              M.get_name (| "Uint" |),
              "wrap"
            |),
            [
              Value.Integer 0
            ]
          |)
        |),
        M.bin_op (|
          "==",
          M.get_name (| "y" |),
          M.call (|
            M.member_access (|
              M.get_name (| "Uint" |),
              "wrap"
            |),
            [
              Value.Integer 0
            ]
          |)
        |)
      |) then
        M.return_ (|
          M.call (|
            M.member_access (|
              M.get_name (| "Uint" |),
              "wrap"
            |),
            [
              Value.Integer 0
            ]
          |)
        |)
      else
        Value.Tuple [] in
    let _ :=
      if M.bin_op (|
        "==",
        M.get_name (| "x" |),
        M.call (|
          M.member_access (|
            M.get_name (| "Uint" |),
            "wrap"
          |),
          [
            Value.Integer 0
          ]
        |)
      |) then
        M.return_ (|
          M.bin_op (|
            "^",
            M.get_name (| "y" |),
            M.get_name (| "x" |)
          |)
        |)
      else
        Value.Tuple [] in
    let _ :=
      M.return_ (|
        M.bin_op (|
          "^",
          M.call (|
            M.member_access (|
              M.get_name (| "Uint" |),
              "wrap"
            |),
            [
              M.bin_op (|
                "-",
                M.call (|
                  M.member_access (|
                    M.get_name (| "Uint" |),
                    "unwrap"
                  |),
                  [
                    M.get_name (| "x" |)
                  ]
                |),
                Value.Integer 1
              |)
            ]
          |),
          M.get_name (| "y" |)
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.
Definition eq (α : list Value.t) : M :=
  match α with
  | [x, y] =>
    let _ :=
      M.return_ (|
        M.bin_op (|
          "==",
          M.call (|
            M.member_access (|
              M.get_name (| "Uint" |),
              "unwrap"
            |),
            [
              M.get_name (| "x" |)
            ]
          |),
          M.call (|
            M.member_access (|
              M.get_name (| "Uint" |),
              "unwrap"
            |),
            [
              M.get_name (| "y" |)
            ]
          |)
        |)
      |) in
    Value.Tuple []
  | _ => M.impossible "invalid number of parameters"
  end.
(* Contract *)
Module C.
  Definition testUnary (α : list Value.t) : M :=
    match α with
    | [x] =>
      let _ :=
        M.return_ (|
          M.un_op (|
            true,
            "~",
            M.get_name (| "x" |)
          |)
        |) in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.

  Definition testBinary (α : list Value.t) : M :=
    match α with
    | [x, y] =>
      let _ :=
        M.return_ (|
          M.bin_op (|
            "^",
            M.get_name (| "x" |),
            M.get_name (| "y" |)
          |)
        |) in
      Value.Tuple []
    | _ => M.impossible "invalid number of parameters"
    end.
End C.
