# ü™®üêì coq-of-solidity
> A formal verification tool for Solidity using the [Coq](https://coq.inria.fr/) proof system

Formal verification is about verifying code for all possible inputs. It goes further than traditional testing that only covers a finite amount of cases. It relies on using mathematical methods to analyze the code.

Formal verification provides:

1. More security for code audits: all the combination of inputs are covered.
2. Reusable audits for future code changes: we can re-run the proofs as the code evolves.

The `coq-of-solidity` project is open-source and uses an interactive theorem prover, Coq, to be able to check arbitrarily complex properties of Solidity smart contracts.

## üôè Thanks

We thanks the [AlephZero Foundation](https://alephzero.org/) for their support and funding this project.

<!-- contact -->
## üì¨ Contact

If you have smart contracts that you wish to audit with a maximum level of security, or want to know more about this project, do not hesitate to contact us at [contact@formal.land](mailto:contact@formal.land).

## üöÄ Quick Start

This project is based on a fork of the [`solc` Solidity compiler](https://github.com/ethereum/solidity). Compile it following the [manual of `solc`](https://docs.soliditylang.org/en/latest/installing-solidity.html#building-from-source) to obtain a `solc` binary.

Then, assuming that you are at the root of this project, run the following commands:

```sh
build/solc/solc --ir-coq my_smart_contract.sol
```

It will pretty-print on the terminal a Coq version of the code. Examples of contracts that are already translated in Coq are in the [CoqOfSolidity/](CoqOfSolidity/) folder. Assuming that you have a working installation of the Coq system, you can compile the existing translated code with:

```sh
cd CoqOfSolidity
make -j4
```

The Coq compilation take a lot of time as there are a lot of generated files.

The translated Coq files can sometimes be a bit too verbose. You can have a better readability by generating the original Yul code that we use to generate the Coq translation with:

```sh
build/solc/solc --ir-optimized my_smart_contract.sol
```

## üèóÔ∏è Architecture

This project is build as a fork of the official `solc` compiler in order to re-use the frontend (parser, type-checker, ...) and stay up-to-date with the Solidity language. The `solc` compiler is a C++ project that compiles Solidity code to EVM bytecode.

We translate the intermediate language [Yul](https://docs.soliditylang.org/en/latest/yul.html) to Coq. Yul is a low-level intermediate language used by the Solidity compiler that is both simpler than Solidity and more high-level than EVM bytecode. The

We then define in Coq the semantics of the Yul language as well as of all the EVM primitives (addition, multiplication, keccak256, contract calls, ...). This is done in the two following files:

To prevent mistakes in our Coq definitions, we also translate the `semanticTests` of the Solidity compiler to Coq and re-run them in Coq. We then check that we get the exact same outputs as on code generated by the official Solidity compiler.

## üìù License

The code of the translation is under the GPL-3.0 license as this is a fork of the Solidity compiler. The code of the Coq semantics is under the MIT license.

## üìö Example

The following Solidity code:

```solidity
function balanceOf(address owner) public view returns (uint256) {
  return _balances[owner];
}
```

translates in Coq to:

```coq
M.function (|
  "fun_balanceOf",
  ["var_owner"],
  ["var"],
  M.scope (
    do* ltac:(M.monadic (
      M.declare (|
        ["zero_t_uint256"],
        Some (M.call (|
          "zero_value_for_split_uint256",
          []
        |))
      |)
    )) in
    do* ltac:(M.monadic (
      M.assign (|
        ["var"],
        Some (M.get_var (| "zero_t_uint256" |))
      |)
    )) in
    do* ltac:(M.monadic (
      M.declare (|
        ["_28_slot"],
        Some ([Literal.number 0x00])
      |)
    )) in
    do* ltac:(M.monadic (
      M.declare (|
        ["expr_54_slot"],
        Some (M.get_var (| "_28_slot" |))
      |)
    )) in
    do* ltac:(M.monadic (
      M.declare (|
        ["_1"],
        Some (M.get_var (| "var_owner" |))
      |)
    )) in
    do* ltac:(M.monadic (
      M.declare (|
        ["expr"],
        Some (M.get_var (| "_1" |))
      |)
    )) in
    do* ltac:(M.monadic (
      M.declare (|
        ["_2"],
        Some (M.call (|
          "mapping_index_access_mapping_address_uint256_of_address",
          [
            M.get_var (| "expr_54_slot" |);
            M.get_var (| "expr" |)
          ]
        |))
      |)
    )) in
    do* ltac:(M.monadic (
      M.declare (|
        ["_3"],
        Some (M.call (|
          "read_from_storage_split_offset_uint256",
          [
            M.get_var (| "_2" |)
          ]
        |))
      |)
    )) in
    do* ltac:(M.monadic (
      M.declare (|
        ["expr_1"],
        Some (M.get_var (| "_3" |))
      |)
    )) in
    do* ltac:(M.monadic (
      M.assign (|
        ["var"],
        Some (M.get_var (| "expr_1" |))
      |)
    )) in
    do* ltac:(M.monadic (
      M.leave (||)
    )) in
    M.pure BlockUnit.Tt
  )
|)
```

The output is much more verbose and must be simplified in a first proof step.
